图形渲染要经过哪几个阶段？

#### what

- 硬件

  > - GPU 3D图形引擎
  >
  >   > 职责：根据一个三维场景中的顶点、纹理等信息，转换成一张二维图像
  >   >
  >   > 三个阶段：应用阶段、几何阶段、光栅化阶段
  >   >
  >   > 在操作系统中表现为OpenGL ES，具体API为[EGL](https://www.khronos.org/registry/EGL/)
  >
  > - 2D图形引擎
  >
  >   > Google抽象的合成组件，在硬件实现中，通常是2D图形引擎，以瑞芯开发板举例
  >   >
  >   > 2D引擎，在操作系统中表现为HWC
  >
  > - CPU
  >
  >   > CPU也被列进来的原因是它是兜底的执行者，一部Android设备中可以没有GPU，使用CPU进行图形渲染，也可以没有HWC，CPU可以处理所有的事情，脏活累活都是它的

- 系统

  > - GraphicBuffer流程过程

- 框架策略

#### test

- 一、开篇

  > 写引言部分
  >
  > 绘制、合成、送显
  >
  > 前两篇关注的是送显之后的显示方式，
  >
  > 实际上，图形显示流程大致分为三个阶段，一帧图像数据的诞生，才是图形系统中最复杂的部分
  >
  > 绘制
  >
  > 严格来说，送显方案不止两种，驱动直连才是最基本的方式，刚刚探讨的两种方案都是在此基础上调用API。不过这是硬件工程师考虑的事情，离普通应用开发工程师实在是太远，所以并没有放在文中讨论
  >
  > fb是如何被生产出来的
  >
  > **一块板子上有哪些硬件？介绍大致的流程以及硬件功能**
  >
  > 先来认识一下硬件有哪些
  >
  > 有CPU、GPU、2d引擎等
  >
  > Linux内核将它们连接在一起，通过fence方式
  >
  > 用户空间的
  >
  > 软件是基于硬件，在讨论fb流传过程之前，我们要先对认识一下硬件
  >
  > 由于消费级芯片（麒麟/天玑/骁龙）公开资料比较少，我们随便找个工业级瑞芯[RK3399](http://opensource.rock-chips.com/images/d/d7/Rockchip_RK3399_Datasheet_V2.1-20200323.pdf)来举例
  >
  > 我是图片
  >
  > 从硬件的角度来说，无非是共享一块内存，CPU把指令发送给GPU，GPU处理完了还给CPU，接着调用HWC进行合成，合成完去送显
  >
  > 我们这里简单点把CPU等同于操作系统
  >
  > 
  >
  > 这几个硬件通过操作系统OS连接在一起，这种跨硬件的同步方式就是大名鼎鼎的Fence机制
  >
  > 由于消费级芯片（麒麟/天玑/骁龙）公开资料比较少，我们随便找个工业级瑞芯[RK3399](http://opensource.rock-chips.com/images/d/d7/Rockchip_RK3399_Datasheet_V2.1-20200323.pdf)来举例，
  >
  > **什么是HWC？**
  >
  > 如果我们去看官网的图形架构设计图，会发现列的有hwc，
  >
  > 得去高通的msm-aosp找对应的实现，
  >
  > 这里分享一下平时如何找代码的，我们都知道Google是Android定义者，最大的下游厂家应该非高通莫属，其次是联发科、以及其他工业消费厂家，他们拿到
  >
  > 对于一个功能要不要实现，怎么实现，由厂商自行决定
  >
  > 手机厂商通常拿到的是高通或联发科的平台代码，在此基础上进行魔改
  >
  > 所以我们这里也以高通为例，打开高通的[开发者社区](https://www.codeaurora.org/)
  >
  > 
  >
  > HWC的具体实现是2D图形引擎，我们知道Android 4.1之后发布了黄油计划
  >
  > 为了避免发生拷贝，一旦发生数据拷贝就意味着数据要发生传输，传输就需要耗能，移动设备最重要的就是能耗
  >
  > 在冯诺伊曼架构的指导下，只要有CPU和内存就可以运行操作系统，把RK3399设计图中多媒体处理中所有硬件全部丢弃依旧可以正常运行，Android系统提供了lib库，通过CPU来执行指令
  >
  > 把渲染和合成分开执行在不同的vsync周期，
  >
  > 在更高的刷新率设备上，每个阶段的耗时也要求越短，所以流水线也会越长，通常会设计成更多的
  >
  > 开发板和普通的手机还是有些区别的，比如mip接口
  >
  > Android开发工程师通常启动activity就可以在屏幕上看到画面，
  >
  > 好了，这下我们知道图像内存是如何流转的，也知道操作系统拥有bufferqueue来管理graphicbuffer

  > 总结一下HWC是流水线上的一环，加入HWC为了解决
  >
  > 还有另外一个hwc用来接受屏幕驱动产生的vsync信号，
  >
  > 好了，现在硬件和系统的关键模块我们都已经了解了，接下来就是让整个流程run起来
  >
  > **1、认识硬件**
  >
  > **2、认识操作系统**
  >
  > 那么接下来我们从
  >
  > 

- 二、视图的加载与graphicbuffer的分配，vsync，系统的总指挥！

  > 咋一看标题很奇怪，视图的加载是在APP用户进程，graphicbuffer分配是在系统进程，中间
  >
  > 每次vsync的到来，app进程，surfaceflinger进程等都要开始工作
  >
  > 每次到来就像领导来视察一样，app开始检查有没有新的变化，sf检查有没有需要合成的layer
  >
  > 1、APP进程
  >
  > 2、sf进程
  >
  > 3、hwc服务
  >

- 结语

  > 在深入了解图形子系统之后，我才发觉这是多么庞大的话题
  >
  > 图形数据本质是二维数组，数组中每个元素描述了像素点的状态
  >
  > 在此之前，
  >
  > 本文把重点放在了介绍GraphicBuffer流转过程，事实上，图形子系统涉及到非常多的模块
  >
  > 
  >
  > 生产一篇文章的过程中，我的习惯是将某个领域的知识点全部查清楚，接着看看能否找到一个切入点引出一条故事线，让这条线尽可能包含整个知识介绍
  >
  > 在二次创作中为了文章不显得太臃肿往往会选择丢弃一部分信息，如果不小心将某个重要的知识点剔除了，我自己在审稿时是发现不了的，因为每个点的上下文我脑子里都有，这部分丢弃信息并不会给我造成理解上的问题
  >
  > 在读者看来非常致命，所以，在这里真诚的请求大家，如果您在阅读文章的过程有任何疑问，请在评论区提出来，我会尽力解答，感谢您的阅读
  >
  > 文章的最后一节列出了，相较于本篇文章，参考资料对Android工程师的帮助显然会更大，它们能够帮助你构建一个完整的图形框架，限于篇幅和个人精力，本篇包含的内容只能说是沧海一粟
  >
  > 全文完
  >
  > 图形子系统涉及到非常多的知识点，
  >
  > 每个环节都非常重要，可以写出一篇文章来介绍，忽略了GPU是如何根据一个三维场景中的顶点、纹理等信息，转换成一张二维图像的，忽略了g是如何申请并管理内存的，忽略了sf是，
  >
  > 最重要的是忽略了DRM架构，这和有关系，比如我们可以来思考一个问题：为什么手机关机还能显示充电画面？单单为了介绍内存数据的流程流程已经耗费了，没有时间和精力去搞懂全部的实现原理

前两篇文章我们分别介绍了屏幕的"显示原理"和屏幕的"刷新原理"，本篇文章我们将要一起来了解Android图形架构是如何设计的，显示流程，在学习刷新原理的文章中，

#### 一、开篇

#### 二、图形送显方案

##### DRM直连

关机充电动画/闹钟画面

surfaceflinger未启动时的开机动画

##### OpenGL ES Native



实际上，framebuffer已经是绘制流程的，的生产和管理，才是图形系统当中最为重要的部分

本篇的重点是关注framebuffer的生成过程，渲染流程

GPU图像渲染流程，内存如何分配，窗口管理等等

每一步又可以继续拆分。比如GPU图形渲染又分为应用阶段、几何阶段、光栅化阶段

其中，几何阶段又可以分为顶点着色器等等

在深入了解OpenGL图形开发一段时间后，我放弃了理解实现原理的想法，太他吗复杂了

所以在此关于渲染流程可能会一笔带过，对于图形开发的当做黑盒处理，塞入数据出来的是framebuffer

理解sf在系统框架中的位置，有助于我们构建Android体系架构

参考资料

- [GPU 渲染管线和硬件架构浅谈-腾讯技术工程](https://mp.weixin.qq.com/s/-ueKhxbsJOnUtV1SC5eyBQ)