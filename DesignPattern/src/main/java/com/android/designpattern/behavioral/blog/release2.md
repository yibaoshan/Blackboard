## 漫谈设计模式（三）：行为型模式

## 一、前言

在漫谈设计模式(一)、(二)中分别介绍了创建型模式和结构型模式，每种类型的设计模式侧重点不同
创建型模式关注的是如何创建对象，为工程师提供服务
结构型模式关注的是如何根据业务解耦各个模块/类，最后通过组合/关联的方式在一起工作，服务于业务

今天要介绍的是设计模式专题中的最后一种类型：行为型模式(Behavioral Pattern)
行为型模式关注的是类或对象的职责分配，同样也是为业务提供服务；和结构型模式相比较，行为型模式关注的粒度更小，更像是对结构型模式的补充

行为型模式有11种，数量看起来会比前两种类型要多，不过随着这些年语言特性和开发模式的进化，能够留下来在项目中真正落地的就不多了。
经过筛选，本文将会介绍行为型中的5种模式：

1. **观察者模式(Observer)**
2. 责任链模式(Chain of Responsibility)
3. 中介者模式(Mediator)
4. 备忘录模式(Memento)
5. 策略模式(Strategy)

以下6种模式不包含在本文中：

1. **命令模式(Command)**：简单的指令封装，参考Java封装概念
2. 解释器模式(Interpreter)：为了解决业务需求必须存在的方案，个人认为称不上是设计模式，参考Android LayoutInflater
3. 迭代器模式(Iterator)：源于容器访问，适用场景单一，参考Java iterator接口
4. 模板方法(Template Method)：规范方法调用顺序，到处都是，参考Android生命周期及各种base层
5. 状态模式(State)：不同的状态下执行不同的策略，个人认为等同策略模式
6. 访问者模式(Visitor)：缺乏落地的业务场景(主要是看不懂)

以上观点属于笔者个人理解，缺乏官方论据支撑，若您发现笔者的描述有不准确甚至完全错误的地方，请到[这里](https://github.com/yibaoshan/Blackboard/issues)进行反馈，感谢

最后，生产者消费者虽然不在23种设计模式中，但考虑到它的使用范围非常广泛，本文将在最后一章番外篇中介绍

以下，enjoy：

## 二、行为型模式：观察者模式
### 1、模式介绍
观察者模式(Observer Pattern)通常有由至少一个可被观察的对象和多个观察这个对象的观察者组成，当被观察者的状态发生变化时，会通知这些观察者
还有一种做法是增加一个中介角色，也叫发布订阅中心，把被观察者中的订阅和通知的逻辑抽离处理放在发布订阅中心，类似于Android EventBus
网上讨论能否将观察者等同于发布/订阅模式的大多数争议的地方就在这一点

为了方便记忆，本章节还是将两者区分开来，即：两个角色的叫观察者模式，三个角色的叫做发布/订阅模式

接下来我们通过类图来看一看两者之间的区别

观察者模式：

我是类图

如图所示，观察者模式一般由至少一个可被观察的对象(示例中的LiveData) ，和多个观察这个对象的观察者(示例中的LiveDataObserver)组成去观察。二者的关系是通过被观察者来建立的，所以在被观察者中，至少要有三个方法：添加观察者、删除观察者、通知消息。
当被观察者将某个观察者添加到自己的观察者列表(observers)后，观察者与被观察者的关联就建立起来了。此后只要被观察者在某种时机触发通知观察者方法时，观察者即可接收到来自被观察者的消息。

发布/订阅模式：

我是类图

如图所示，发布订阅模式是将原先在被观察者中的添加、删除、通知逻辑抽离出来，放在发布订阅中心；观察者和被观察者之间不直接进行通讯，而是发布者将要发布的消息交由中心管理，订阅者也是根据自己的情况，按需订阅中心中的消息。

讲完了两者的区别后，我们通过两个简单的代码示例来分别实现一下观察者模式和发布/订阅模式：

### 2、代码示例

观察者模式：

```java
//定义通知方法及值类型
public interface Observer<T> {
    void onChanged(T t);
}
//被观察者
public class LiveData<T> {
    private final List<Observer<T>> observers = new LinkedList<>();
    
    //添加观察者
    public void addObserver(Observer<T> observer) {
        observers.add(observer);
    }
    
    //删除观察者
    public void remove(Observer<T> observer) {
        observers.remove(observer);
    }
    
    //通知消息
    public void setValue(T t) {
        for (Observer<T> observer : observers) observer.onChanged(t);
    }
}
//观察者
public class LiveDataObserver implements Observer<String>{

    @Override
    public void onChanged(String s) {
        System.out.println("received message:"+s);
    }
}
//测试类
public class Test {

    @org.junit.Test
    public void main() {
        LiveData<String> liveData = new LiveData<>();
        liveData.addObserver(new LiveDataObserver());
        liveData.setValue("404");
    }

}
```

打印结果：

```java
received message:404
```

发布/订阅模式：

### 3、源码锚点

### 4、小结

本章节把观察者等同于发布/订阅，至于网上讨论的观察者模式和发布/订阅是否有区别，我个人认为大可不必纠结，他们唯一的区别只是要不要把订阅&通知的逻辑单独拎出来而已
重要的是理解设计模式解决了哪些问题以及落地，在实现方案中多一个或少一个角色没什么影响

## 三、行为型模式：责任链模式

## 四、行为型模式：中介者模式

## 五、行为型模式：备忘录模式

## 六、行为型模式：策略模式

## 七、番外篇：生产者-消费者模式
### 1、模式介绍

生产者-消费者模式虽然不在23种设计模式之列，但我认为它在业务中的重要性不亚于23种设计模式中任何一种
无论是Android客户端的Handler机制，还是后端的各种MQ消息中间件，包括java.util.concurrent包的线程池，他们的设计思想都是基于生产者-消费者模式
简单一句话概括什么是生产者消费者模式：多个进程/线程共享一个阻塞队列，生产者负责push任务进队列，消费者负责取出任务去执行

我是类图

### 2、源码示例

笔者是Android工程师，所以本章节我们简单来探讨一下Handler机制的设计
Android Handler机制

### 3、小结

实际上，不只是Android，其他操作系统，即使在多线程设备中，应用程序用户界面也始终是单线程的，即UI线程(User Interface Thread)，比如iOS和Windows
对显示内容的任何更改都需要通过单个"接入点"进行协调，这可以防止多个线程尝试同时更新同一像素

## 八、总结

至此，设计模式三大类型都已经介绍完了，我们再来简单回顾一下：

在设计业务的时候，结构型和行为型相比而言，前者讲思想，后者讲行为

这篇文章耗时超出笔者预期了，大部分时间都花在理解每种设计模式诞生的背景、能够解决哪些问题、以及能否在项目中落地
举个例子，策略模式是什么，经过查阅好几本书籍和主流博客后笔者认为，选择不同的策略的这个行为本身，叫做策略模式，但凡有一点意义，也不至于一点意义都没有


行为型模式的数量看起来比较多，命令模式和解释器模式，稍有开发经验的工程师，为了代码的可读性，但随着语言特性和开发模式的进化，能够留下来在项目中真正落地的就不多了

## 九、参考资料

[Wilson712：理解【观察者模式】和【发布订阅】的区别](https://juejin.cn/post/6978728619782701087)

[flyingcr：经典并发同步模式：生产者-消费者设计模式](https://zhuanlan.zhihu.com/p/73442055)