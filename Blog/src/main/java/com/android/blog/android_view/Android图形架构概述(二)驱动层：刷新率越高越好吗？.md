# Android图形架构概述(上)：硬件和屏幕驱动


本篇内容偏向嵌入式开发工程师，屏幕驱动是屏幕厂商出厂配置好的，你只能根据他们提供的接口来更改参数

少有能直接写驱动代码烧录进去

对于应用开发工程师来说，虽然我们不需要写驱动程序，但是了解View是最终如何显示到屏幕上还是非常有必要的

本篇是View系列的第一篇文章，主要讨论的是Android手机屏幕的种类以及和屏幕相关的技术名词，相信读完本文后

比如屏幕刷新率和FPS是什么关系，两者有什么区别与联系

为什么有的应用在90HZ屏幕体验良好，在120HZ屏幕上很卡顿

身为应用开发工程师，我们能做哪些优化来提升用户体验等等问题都得出自己的答案

## 一、开篇

手机屏幕发展至今，市场上在售手机的屏幕类型基本可以分为两种：LCD屏和OLED屏

其实不只是手机屏幕，电脑和电视屏幕面板基本也就这两种

我们平时在买屏幕时看到的IPS屏幕，TN屏等都属于LCD屏阵营，他们的区别只是液晶层结构或者背光模组结构不同

OLED屏幕因为价格比较贵，寿命也比不过LCD屏，所以OLED在显示器和电视机领域还没有大面积应用

但在手机圈，各大厂商自2020年之后生产的旗舰机，几乎都标配OLED屏幕

相较于LCD屏幕

- OLED屏幕支持更高的亮度、对比度以及更艳丽的色彩
- 更快的响应速度，高刷体验更好
- 不需要背光板，采用COP方案封装，理论上可以去掉宽下巴

在手机屏幕追求超高屏占比的时代，LCD被彻底的抛下车

但是，虽然OLED屏有许多LCD无法比拟的优势，但它同时也带了两个新的问题：烧屏和低频PWM调光

### OLED屏缺陷：烧屏

烧屏指的是手机屏幕长时间停留在某个静止画面，特别是极个别高对比度画面，再切换到其他画面时仍然能看到原来画面的残影，而且残影不会消失

比如我之前在拼多多上买的二手Pixel 3就发现老化烧屏的现象

我是图片

仔细观察位置信息一栏会发现，在屏幕上残留的有谷歌邮箱的图标icon

如今厂商用各种方案为OLED延长使用寿命，例如定期改变虚拟导航栏的位置、定期调节色温等等，但是现阶段烧屏问题还是会普遍存在的OLED屏幕上

烧屏是一个不可逆的过程，一旦手机出现烧屏，会严重影响日常的使用体验，不能忍的话只能换屏幕或者换手机

B站评论截图

### 为什么OLED会烧屏？

我们先来看LCD屏和OLED屏的结构组成

LCD是由背光模组，下偏光片，液晶层，滤光层和上偏光片组成，通过改变施加在液晶层上的电压大小来控制每个像素点颜色

我是图片

OLED是有机发光材料作发光层，发光层上方有一层低功函数的金属电极，构成如三明治的结构，通过改变施加在自发光二极管上的电压大小来控制每个红黄蓝子像素亮度，进而改变每个像素点的颜色

我是图片

*对OLED发光原理感兴趣的可以看这篇文章《[OLED发光原理和OLED面板结构及OLED关键技术深度图文解析](http://www.51touch.com/technology/touchpanel/201808/28-51282.html)》，文中的知识点大而全，从发光原理到驱动技术再到制造和封装全流程无死角覆盖*

**LCD屏幕基板**是无机玻璃材料，所以几乎不会发生老化，而**OLED基板**是**有机塑料材料**，就意味着它会渐渐老化

那么问题来了，LCD要么全亮要么全灭，所以就算老化，也是全部老化，你也看不出来

OLED由于每个像素点是自发光，而不是LCD那样整块全部亮，这就会导致OLED每个像素点工作的时间不一样

有的像素点显示蓝色的时间长，那么他的蓝色衰减就会比其他像素点多，日后再显示蓝色的时候这一个像素点的蓝色就要比其余的淡一点，同样的红色和绿色也是一样

所以OLED屏幕非常容易发生一个现象就是烧屏，本质就是屏幕老化不均匀导致的残留

### 如何减缓烧屏过程

既然OLED烧屏不可避免，作为消费者我们可以做些什么来减缓烧屏现象呢？

除了定期更换壁纸、调短屏幕**自动锁定**的时间等手段外，我个人发现了一个更好的方案，能够从根本上解决烧屏的可能性：read more books, read more newspapers, eat less snacks and sleep more

### OLED屏缺陷：低频PWM调光

低频PWM调光是OLED屏上另一个被人诟病的问题，甚至因为有人无法接受，从而诞生出“LCD永不为奴”党，注意我这里用的是“低频”

绝大多数OLED屏幕都是使用PWM调光，PWM本身没问题，只要速度够快人眼是感知不到的

开局放图

### PWM调光原理

首先我们需要了解什么是“视觉残留”现象，当人看到一幅画面快速闪过时，这幅画面产生的视觉刺激会在大脑中停留几十到几百毫秒时间，亮度越亮，停留的时间越长

这一特征我们称为视觉残留



以我手里的[Pixel 3](https://www.notebookcheck.net/Google-Pixel-3-Smartphone-Review.366326.0.html#toc-9)举例，PWM调光频率为245HZ

对自己手机屏幕参数感兴趣的同学可以去这个网站查询：www.notebookcheck.net

低频的PWM调光会给眼睛带来额外的负担，而且如果频率太低，还可能引发癫痫

PWM周期、原理、占空比

OLED屏幕烧屏和低频PWM调光都已经介绍完了，各大手机厂商也都在积极解决

比如黑鲨手机加入定制显示芯片在低亮度下做出补偿

当然LCD永不为奴党

苹果最后一代使用旗舰芯片的手机是iPhone 11

Android阵营，黑鲨游戏手机

## 二、屏幕刷新机制

屏幕刷新机制包含的技术名词挺多的，比如逐行扫描，刷新率，双重缓冲，vsync信号等等

我们从一张下面动图展开，

上一章节介绍了PWM调光，

图里手机是我的pixel 3，运行的App不停的在蓝色和红色之间来回切换

我们看到的是什么？是屏幕的逐行扫描在刷新屏幕吗我们看到的是逐行扫描刷新吗？

手机屏幕电路板应该都是矩阵，线为什么是斜着的

我们眼睛看到的究竟是什么

下面我们就一起来搞清楚这几个问题

前一章介绍了屏幕的组成结构和调光方式，本章屏幕刷新机制



### LCD屏幕

LCD

由于显示原理的不同，这两种屏幕分别有自己的特点

LDC结构比较复杂，

通常是三层结构组成，最底层是显示屏，然后是触摸屏，最上面一层是玻璃

应用在手机上的触摸屏基本都是电容屏，没什么好介绍的

### 三、调光方式

#### DC调光

调节屏幕背光供给电压大小，就可以改变亮度

#### PWM调光

### 四、屏幕刷新机制

#### 屏幕刷新原理

逐行扫描

#### 屏幕撕裂



Android图形架构概述(驱动层)：vsync是如何解决画面撕裂问题的？

> 双缓冲机制
>
> 现在我们跳出Android手机，看看PC的设计
>
> 屏幕板子上有块内存，用于记录像素buffer，屏幕驱动按照刷新率去内存读取，所谓双缓冲，指的
>
> 多重缓冲也是可以的，代价是更高的延迟
>
> 作者：TC130
> 链接：https://zhuanlan.zhihu.com/p/385642198
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 
>
> 假设现在我们只有一个buffer，表示当前需要显示到显示器上的内容。当一帧中的三角形被绘制时，会随着显示器的刷新，逐渐一点点出现，这种效果是很奇怪的。即使我们的帧率和显示器刷新率相等，single buffer 还是会有问题。如果我们决定清除 buffer 然后绘制一个较大的三角形，因为VDC 会将正在绘制的color buffer区域输出，我们就会短暂地看到 color buffer的变化。这种现象叫做**撕裂/tearing**，画面显示看起来被分割成了两部分。在一些像Amiga 的古老系统中，你可以通过检测 Beam来防止画面撕裂，这样single buffering就是可行的。现在只有在一些 VR系统中才会用到这种 single bugger渲染架构，会使用 beam 方式来尽可能降低延迟。
>
> 目前最常用的消除撕裂的方式是使用 double buffering。一个渲染完成的图像在 **front buffer** 中显示，同时不可见的的 **back buffer** 在被绘制。当back buffer 中的图像被传输到显示器后，图形驱动会 swap front buffer 和 back buffer，来避免撕裂。Swap的过程通常都是简单地交换两个 color buffer的指针。对于 CRT 显示器，这个事件叫做 vertical retrace，整个过程叫做 **vertical synchronization / Vsync / 垂直同步**。虽然LCD 显示器没有 beam 的 retace，但是我们使用相同的术语来表示显示器中的交换过程。
>
> 如果渲染过程完成后，立即交换 back buffer 和 front buffer，可以最大化帧率，这样可以用来测试渲染系统的性能。但是这样其实是没有跟随 vsync 来进行更新的，同样会造成撕裂。不过因为两个buffer 都是渲染好的完整图像，撕裂效果不会像 single buffer 中那样糟糕。
>
> 对 double buffering 进行改进，添加上 pending buffer， 就形成了 triple buffering。pending buffer 和 back buffer 类似，都是不可见的，不同的是 pending buffer 是可以被修改的。pending buffer 在交换之后，会变成 back buffer。再次 swap 后，成为 front buffer。这样，三种buffer 构成了循环，如上图所示。
>
> 使用 doule buffering 时，等待垂直刷新及swap时，front buffer 需要被显示，而 back buffer 因为是已经渲染好的图像，所以需要保持不变，等待被显示。相对 double buffering，triple buffering的优势在于，当等待垂直刷新的时候，系统可以访问 pending buffer。这样 triple buffering 避免了等待的时间，从而增加帧率。不过相应的缺点就是，会增加整整一帧的延迟，会给用户从手柄鼠标键盘的输入增加延迟，甚至产生卡顿。
>
> 理论上来说，超过三个的buffer 也是可行的。如果每帧渲染的时间波动很大，使用更多的buffer，就能使结果更平滑，帧率更高，当然代价就是更大的延迟。

Android图形架构概述(系统层)：Flutter没有继承View为什么能在屏幕上显示？

> 在Android4.1之前是不支持vsync信号的，哪怕硬件驱动支持
>
> 在驱动层我们知道，VSync信号是由GPU驱动或者屏幕驱动产生的，假设手机驱动不支持怎么办？
>
> Android4.1中提供了*VSyncThread*来软件模拟
>
> 引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作
>
> 画图：你使用canvas api 还是OpenGL es都可以
>
> 合成：surfaceFligler只管合成图像
>
> 疑问❓：三重缓冲

Android图形架构概述(番外篇)：Input事件先到达DecorView还是Activity？

View系列开篇：什么是刷新率

事情是这样的，

屏幕显示原理：    

LCD屏幕：DC调光

OLED屏幕：PWM调光

逐行刷新

屏幕撕裂

vsync信号

引申出屏幕gif动图

市面上手机屏幕分为两种

一种是LCD屏幕，使用DC调光

屏幕其实是由一个个像素点组成的，每个像素点





范围：  
屏幕的显示原理  
    逐列刷新、逐行刷新
    屏幕最终要的数据类型是每一行的RGB值，

    调光方式，DC调光和PWM调光
    有了上述理论知识以后，我们来看一个现象，这有什么用呢？我们可以看到很有趣的现象
    
    快门速度：
    简单来说就是曝光时间，快门帘打开让光线进入传感器的时间
    
    占空比：
    PWM一个周期计算公式：
    T = 1/f
    周期 = 
    
    我们看到的是什么？


屏幕撕裂

垂直同步信号

讨论一下，高刷屏对于工程师的挑战

对于硬件工程师来说，大部分主板上CPU和GPU共享一块内存，所以屏幕色深值越高，描述每个像素点需要内存就越大，内存的大小和内存的访问速度绝不能拉胯
屏幕刷新率高了，CPU和GPU需要在更短的时间处理数据，在提升硬件性能的同时还需要平衡功耗控制

对于应用开发工程师来说，在View绘制，做好性能优化这块展开可以聊很久

B站评论
科普下，我是做FPGA摄像头视频采集的。摄像头原始出来的格式常用的是RGB565。也就是R红色占5位，G绿色占6位，B蓝色占5位。加起来刚好16位，两个字节。   而显示器需要的是RGB888格式如其名，每个像素占8位。有就是三个字节。  1920x1080个像素点如果是RGB565格式一帧图片多大呢你算下大概6.2M，那显示40帧多少呢一秒就需要248M。注意是1秒哦。    所以图像不压缩真的真的太大了。所以流水线串行的CPU根本处理不了图像。理论上可以，就是巨慢。  所以才会有显卡。并行的1900个流处理器同时处理那么多像素。比cpu快多了。

## 参考资料

- 走进自带光芒的有机发光二极管（OLED）材料绚丽多彩世界，领悟前沿的研究进展：http://www.cailiaoniu.com/232822.html
- 有机发光二极管| 8优点和缺点：https://zh-cn.lambdageeks.com/organic-light-emitting-diodes/
- [OLED发光原理和OLED面板结构及OLED关键技术深度图文解析](http://www.51touch.com/technology/touchpanel/201808/28-51282.html)
- PWM调光科普(上篇)：人类显示器的黑历史：https://www.igao7.com/news/201807/oJMDaPCKHbeufGdI.html