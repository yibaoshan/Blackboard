# Android图形系统（二）驱动层：高刷屏给硬件工程师带来哪些挑战？

对于应用开发工程师来说，虽然我们不需要写驱动程序，但是了解View最终是如何显示到屏幕上还是非常有必要的

本篇是Android图形系列的第二篇文章，讨论的依旧是屏幕显示的基础概念，和Android系统本身没有太大关。和第一篇文章不同的是，本篇重点在于刷新率相关知识点，比如：

> 帧率与刷新率的区别，帧率是不是一定要和刷新率匹配，不匹配的话多出来的帧率是不是浪费了？
> 垂直同步信号的出现是为了解决什么问题？
> 为什么有的应用在60HZ屏幕体验很好，在120HZ屏幕上却出现卡顿？
> 等等...

overview图片

## 一、开篇：屏幕显示原理

“逐行扫描”是屏幕显示时使用的一项技术，指的是，以一块1920*1080分辨率的屏幕举例，还有一种方式叫做“隔行扫描”，要追溯到，现在的手机屏幕几乎不用这种方案

这是显示端，在拍摄端

> 更高的刷新率意味着需要：
> 更快的处理速度，更高规格的CPU、GPU
> 更大容量的电池
> 更高的触控采样率

说了这么多，我们能看到逐行刷新的过程吗？虽然我不知道它是如何发生的，但是用来帮助理解逐行刷新应该还是可以的

## 二、屏幕刷新机制

屏幕刷新机制包含的技术名词挺多的，比如逐行扫描，刷新率，双重缓冲，vsync信号等等

我们从一张下面动图展开，

上一章节介绍了PWM调光，

图里手机是我的pixel 3，运行的App不停的在蓝色和红色之间来回切换

我们看到的是什么？是屏幕的逐行扫描在刷新屏幕吗我们看到的是逐行扫描刷新吗？

手机屏幕电路板应该都是矩阵，线为什么是斜着的

我们眼睛看到的究竟是什么

下面我们就一起来搞清楚这几个问题

前一章介绍了屏幕的组成结构和调光方式，本章屏幕刷新机制



### LCD屏幕

LCD

由于显示原理的不同，这两种屏幕分别有自己的特点

LDC结构比较复杂，

通常是三层结构组成，最底层是显示屏，然后是触摸屏，最上面一层是玻璃

应用在手机上的触摸屏基本都是电容屏，没什么好介绍的

### 三、调光方式

#### DC调光

调节屏幕背光供给电压大小，就可以改变亮度

#### PWM调光

### 四、屏幕刷新机制

#### 屏幕刷新原理

逐行扫描

#### 屏幕撕裂



Android图形架构概述(驱动层)：vsync是如何解决画面撕裂问题的？

> 双缓冲机制
>
> 现在我们跳出Android手机，看看PC的设计
>
> 屏幕板子上有块内存，用于记录像素buffer，屏幕驱动按照刷新率去内存读取，所谓双缓冲，指的
>
> 多重缓冲也是可以的，代价是更高的延迟
>
> 作者：TC130
> 链接：https://zhuanlan.zhihu.com/p/385642198
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 
>
> 假设现在我们只有一个buffer，表示当前需要显示到显示器上的内容。当一帧中的三角形被绘制时，会随着显示器的刷新，逐渐一点点出现，这种效果是很奇怪的。即使我们的帧率和显示器刷新率相等，single buffer 还是会有问题。如果我们决定清除 buffer 然后绘制一个较大的三角形，因为VDC 会将正在绘制的color buffer区域输出，我们就会短暂地看到 color buffer的变化。这种现象叫做**撕裂/tearing**，画面显示看起来被分割成了两部分。在一些像Amiga 的古老系统中，你可以通过检测 Beam来防止画面撕裂，这样single buffering就是可行的。现在只有在一些 VR系统中才会用到这种 single bugger渲染架构，会使用 beam 方式来尽可能降低延迟。
>
> 目前最常用的消除撕裂的方式是使用 double buffering。一个渲染完成的图像在 **front buffer** 中显示，同时不可见的的 **back buffer** 在被绘制。当back buffer 中的图像被传输到显示器后，图形驱动会 swap front buffer 和 back buffer，来避免撕裂。Swap的过程通常都是简单地交换两个 color buffer的指针。对于 CRT 显示器，这个事件叫做 vertical retrace，整个过程叫做 **vertical synchronization / Vsync / 垂直同步**。虽然LCD 显示器没有 beam 的 retace，但是我们使用相同的术语来表示显示器中的交换过程。
>
> 如果渲染过程完成后，立即交换 back buffer 和 front buffer，可以最大化帧率，这样可以用来测试渲染系统的性能。但是这样其实是没有跟随 vsync 来进行更新的，同样会造成撕裂。不过因为两个buffer 都是渲染好的完整图像，撕裂效果不会像 single buffer 中那样糟糕。
>
> 对 double buffering 进行改进，添加上 pending buffer， 就形成了 triple buffering。pending buffer 和 back buffer 类似，都是不可见的，不同的是 pending buffer 是可以被修改的。pending buffer 在交换之后，会变成 back buffer。再次 swap 后，成为 front buffer。这样，三种buffer 构成了循环，如上图所示。
>
> 使用 doule buffering 时，等待垂直刷新及swap时，front buffer 需要被显示，而 back buffer 因为是已经渲染好的图像，所以需要保持不变，等待被显示。相对 double buffering，triple buffering的优势在于，当等待垂直刷新的时候，系统可以访问 pending buffer。这样 triple buffering 避免了等待的时间，从而增加帧率。不过相应的缺点就是，会增加整整一帧的延迟，会给用户从手柄鼠标键盘的输入增加延迟，甚至产生卡顿。
>
> 理论上来说，超过三个的buffer 也是可行的。如果每帧渲染的时间波动很大，使用更多的buffer，就能使结果更平滑，帧率更高，当然代价就是更大的延迟。

Android图形架构概述(系统层)：Flutter没有继承View为什么能在屏幕上显示？

> 在Android4.1之前是不支持vsync信号的，哪怕硬件驱动支持
>
> 在驱动层我们知道，VSync信号是由GPU驱动或者屏幕驱动产生的，假设手机驱动不支持怎么办？
>
> Android4.1中提供了*VSyncThread*来软件模拟
>
> 引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作
>
> 画图：你使用canvas api 还是OpenGL es都可以
>
> 合成：surfaceFligler只管合成图像
>
> 疑问❓：三重缓冲

Android图形架构概述(番外篇)：Input事件先到达DecorView还是Activity？

View系列开篇：什么是刷新率

事情是这样的，

屏幕显示原理：    

LCD屏幕：DC调光

OLED屏幕：PWM调光

逐行刷新

屏幕撕裂

vsync信号

引申出屏幕gif动图

市面上手机屏幕分为两种

一种是LCD屏幕，使用DC调光

屏幕其实是由一个个像素点组成的，每个像素点





范围：  
屏幕的显示原理  
    逐列刷新、逐行刷新
    屏幕最终要的数据类型是每一行的RGB值，

    调光方式，DC调光和PWM调光
    有了上述理论知识以后，我们来看一个现象，这有什么用呢？我们可以看到很有趣的现象
    
    快门速度：
    简单来说就是曝光时间，快门帘打开让光线进入传感器的时间
    
    占空比：
    PWM一个周期计算公式：
    T = 1/f
    周期 = 
    
    我们看到的是什么？


屏幕撕裂

垂直同步信号

讨论一下，高刷屏对于工程师的挑战

对于硬件工程师来说，大部分主板上CPU和GPU共享一块内存，所以屏幕色深值越高，描述每个像素点需要内存就越大，内存的大小和内存的访问速度绝不能拉胯
屏幕刷新率高了，CPU和GPU需要在更短的时间处理数据，在提升硬件性能的同时还需要平衡功耗控制

对于应用开发工程师来说，在View绘制，做好性能优化这块展开可以聊很久

B站评论
科普下，我是做FPGA摄像头视频采集的。摄像头原始出来的格式常用的是RGB565。也就是R红色占5位，G绿色占6位，B蓝色占5位。加起来刚好16位，两个字节。   而显示器需要的是RGB888格式如其名，每个像素占8位。有就是三个字节。  1920x1080个像素点如果是RGB565格式一帧图片多大呢你算下大概6.2M，那显示40帧多少呢一秒就需要248M。注意是1秒哦。    所以图像不压缩真的真的太大了。所以流水线串行的CPU根本处理不了图像。理论上可以，就是巨慢。  所以才会有显卡。并行的1900个流处理器同时处理那么多像素。比cpu快多了。

## 结语

文章内容是应用工程师对驱动开发的理解，若有偏差请在评论区指出，感谢

## 参考资料

- OLED的几种驱动方式：https://wenku.baidu.com/view/9a1279ceda38376baf1fae70.html?re=view

## 待办

### 1、本章涵盖知识点

1. 屏幕显示原理
   1. 逐行扫描：从上到下从左到右的顺序，多行一起替换，需要电路板佐证
      1. 介绍逐行扫描的概念
      2. 看一张动图，解释这不是逐行扫描但是可以看做是逐行扫描
      3. 看电路图，解释虽然是从上到下从左到右的顺序，但是实际执行是多行替换
2. 屏幕刷新率
   1. 帧率和刷新率
      1. 屏幕VBlack的越快，屏幕刷新的就越高，这个周期，或者说刷新的速度，就是屏幕刷新率
      2. 屏幕刷新率取决于什么呢？显然是屏幕本身的素质，也就是屏幕响应时间
      3. 能不能改变屏幕刷新率呢？屏幕刷新率超频，既然屏幕刷新率高低取决于屏幕素质，那刷新率能不能像CPU一样超频使用呢？答案是可以的，虽然我不清楚底层是改驱动实现的还是怎么样，但的确，另外，超频可能会和采样率等挂钩，可能会点击偏移，在超频之前可以去论坛看看有没有成功的先例，就算没问题有的机型可能也会出现卡顿的情况，原因我待会再说
   2. 帧率FPS
      1. 说完了刷新率，我们来看看帧率是什么，我平时打游戏时除了关注网络延迟外，通常还会关注FPS这个指标，FPS越高游戏画面越流畅
3. 画面撕裂的终结者：vsync
   1. 前面介绍了FPS和刷新率之间的关系，接着我们来看一个现象，画面为什么会撕裂呢？不匹配，如何解决呢
   2. vsync信号，带来的问题，浪费显卡性能，如何解决？多重缓冲，带来另一个问题，鼠标IO事件延迟，如何解决
   3. G sync和free sync信号
4. 回到标题
   1. 带来哪些挑战
      1. 屏幕本身素质表现，需要能够快速切换像素，也就是屏幕响应时间
      2. 高性能的CPU和GPU，对于屏幕来说，GPU的性能更加重要，GPU的显存
      3. 主板设计，CPU和GPU共用内存