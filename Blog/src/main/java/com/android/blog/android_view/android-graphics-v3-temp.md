#### what

- 硬件

  > - GPU 3D图形引擎
  >
  >   > 职责：根据一个三维场景中的顶点、纹理等信息，转换成一张二维图像
  >   >
  >   > 三个阶段：应用阶段、几何阶段、光栅化阶段
  >   >
  >   > 在操作系统中表现为OpenGL ES，具体API为[EGL](https://www.khronos.org/registry/EGL/)
  >
  > - 2D图形引擎
  >
  >   > Google抽象的合成组件，在硬件实现中，通常是2D图形引擎，以瑞芯开发板举例
  >   >
  >   > 2D引擎，在操作系统中表现为HWC
  >
  > - CPU
  >
  >   > CPU也被列进来的原因是它是兜底的执行者，一部Android设备中可以没有GPU，使用CPU进行图形渲染，也可以没有HWC，CPU可以处理所有的事情，脏活累活都是它的

- 系统

  > - GraphicBuffer流程过程

- 框架策略

#### test

- 一、开篇

  > 实际上，图形显示流程大致分为三个阶段，一帧图像数据的诞生，才是图形系统中最复杂的部分
  >
  > 绘制
  >
  > 严格来说，送显方案不止两种，驱动直连才是最基本的方式，刚刚探讨的两种方案都是在此基础上调用API。不过这是硬件工程师考虑的事情，离普通应用开发工程师实在是太远，所以并没有放在文中讨论
  >
  > fb是如何被生产出来的

- 视图的加载与graphicbuffer的分配

  > 咋一看标题很奇怪，视图的加载是在APP用户进程，graphicbuffer分配是在系统进程，中间

- 结语

  > 在深入了解图形子系统之后，我才发觉这是多么庞大的话题
  >
  > 图形数据本质是二维数组，数组中每个元素描述了像素点的状态
  >
  > 在此之前，
  >
  > 本文把重点放在了介绍GraphicBuffer流转过程，事实上，图形子系统涉及到非常多的模块
  >
  > 
  >
  > 生产一篇文章的过程中，我的习惯是将某个领域的知识点全部查清楚，接着看看能否找到一个切入点引出一条故事线，让这条线尽可能包含整个知识介绍
  >
  > 在二次创作中为了文章不显得太臃肿往往会选择丢弃一部分信息，如果不小心将某个重要的知识点剔除了，我自己在审稿时是发现不了的，因为每个点的上下文我脑子里都有，这部分丢弃信息并不会给我造成理解上的问题
  >
  > 在读者看来非常致命，所以，在这里真诚的请求大家，如果您在阅读文章的过程有任何疑问，请在评论区提出来，我会尽力解答，感谢您的阅读
  >
  > 文章的最后一节列出了，相较于本篇文章，参考资料对Android工程师的帮助显然会更大，它们能够帮助你构建一个完整的图形框架，限于篇幅和个人精力，本篇包含的内容只能说是沧海一粟
  >
  > 全文完
  >
  > 图形子系统涉及到非常多的知识点，
  >
  > 每个环节都非常重要，可以写出一篇文章来介绍，忽略了GPU是如何根据一个三维场景中的顶点、纹理等信息，转换成一张二维图像的，忽略了g是如何申请并管理内存的，忽略了sf是，
  >
  > 最重要的是忽略了DRM架构，这和有关系，比如我们可以来思考一个问题：为什么手机关机还能显示充电画面？单单为了介绍内存数据的流程流程已经耗费了，没有时间和精力去搞懂全部的实现原理

前两篇文章我们分别介绍了屏幕的"显示原理"和屏幕的"刷新原理"，本篇文章我们将要一起来了解Android图形架构是如何设计的，显示流程，在学习刷新原理的文章中，

#### 一、开篇

#### 二、图形送显方案

##### DRM直连

关机充电动画/闹钟画面

surfaceflinger未启动时的开机动画

##### OpenGL ES Native



实际上，framebuffer已经是绘制流程的，的生产和管理，才是图形系统当中最为重要的部分

本篇的重点是关注framebuffer的生成过程，渲染流程

GPU图像渲染流程，内存如何分配，窗口管理等等

每一步又可以继续拆分。比如GPU图形渲染又分为应用阶段、几何阶段、光栅化阶段

其中，几何阶段又可以分为顶点着色器等等

在深入了解OpenGL图形开发一段时间后，我放弃了理解实现原理的想法，太他吗复杂了

所以在此关于渲染流程可能会一笔带过，对于图形开发的当做黑盒处理，塞入数据出来的是framebuffer

理解sf在系统框架中的位置，有助于我们构建Android体系架构

参考资料

- [GPU 渲染管线和硬件架构浅谈-腾讯技术工程](https://mp.weixin.qq.com/s/-ueKhxbsJOnUtV1SC5eyBQ)