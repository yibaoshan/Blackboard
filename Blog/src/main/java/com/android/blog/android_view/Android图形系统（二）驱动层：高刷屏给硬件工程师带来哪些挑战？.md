# Android图形系统（二）驱动层：高刷屏给硬件工程师带来哪些挑战？

对于应用开发工程师来说，虽然我们不需要写驱动程序，但是了解View最终是如何显示到屏幕上还是非常有必要的

本篇是Android图形系列的第二篇文章，依旧是关于屏幕的一些名词解释，和Android系统本身没有太大关系；和第一篇文章不同的是，本篇重点在于刷新率相关知识点，比如：

> **帧率与刷新率的区别，帧率是不是一定要和刷新率匹配，不匹配时多出来的帧率是不是浪费了？**
>
> **垂直同步信号的出现是为了解决什么问题？**
>
> **电脑开启了垂直同步后感觉更卡了？**
>
> **为什么有的应用在60HZ屏幕体验很好，在120HZ屏幕上却出现卡顿？**
>
> **...**

屏幕刷新机制涉及到许多技术名词：隔行/逐行扫描、刷新率、帧率、画面撕裂、垂直同步信号、双重缓存等等，每项技术都是为了解决某个问题而生；因此，为了更好的理解每项技术诞生的背景，个人墙裂建议按照顺序阅读本文

overview图片

*ps：本文是笔者作为应用工程师对驱动开发的理解，若是相关从业者发现本文的描述错误的地方请及时指出，万分感谢*

## 一、开篇

我们平时用的手机/电脑显示器的形状通常是矩形，当需要将一张图片显示到屏幕上时，芯片会将图片的RGB数据使用“逐行扫描”的方式显示到屏幕上；

“逐行扫描”是一种显示刷新的技术之一，指的是一帧完整的画面是按照从上到下、从左到右的顺序连续扫描到屏幕上，如果用高速摄像机拍摄手机屏幕，就可以看到画面是从上到下的一点点展示出来

gif动图

上面是模拟“逐行扫描”的演示图，程序中运行的是一个自定义View不停的在蓝色和红色之间来回切换

由于手机屏幕上的驱动多为“动态驱动”，单次更新的行数是可控制的，以一块分辨率为1920*1080的屏幕举例，像素刷新并不是从上到下扫描1080行，具体更新多少行是由IC驱动控制；

假设每次同时更新10行像素，那么单位时间内只需要扫描1080/10，即108次

与“逐行扫描”对应的另一种方式叫做“隔行扫描”

### 古老的刷新方式：隔行扫描

“隔行扫描”的历史要追溯到上世纪50年代的CRT时期，由于当时的广播电视传输的带宽不够，所以一幅画面的数据会按照奇偶数分成两次传输，其中奇数行称为上场，偶数行称为下场

显示器每次接收到的都是半幅画面，在PAL制式和NTSC制式中，显示器接受到数据后会先显示奇数行，再显示偶数行，两次显示后凑成一幅完整的图像

由于现在的手机屏幕和电脑显示器几乎都使用的是“逐行扫描”方案，关于“隔行扫描”这里也就不过多介绍了

哦对了，还有一点需要补充，“逐行扫描”的视频后缀用P标识(Progressive)，“隔行扫描”用i标识(Interlaced)，比如1080P意思就是“逐行扫描”的视频，1080i是“隔行扫描”的视频，了解这一点对爱好摄影的小伙伴可能会有所帮助

> - **视频拍摄：我们在拍摄视频时尽可能选择以P结尾的格式，也就是“逐行扫描”比如720P/1080P，如果不小心以720i/1080i格式完成了录制，后期压制时也可以进行反交错**
> - **视频制作：在使用PR导出视频时，同样也要选择以P结尾的格式，否则导出是“隔行扫描”的视频，用“逐行扫描”的显示器播放“隔行扫描”的视频会出现横纹、残影、不流畅等现象**



## 二、屏幕刷新

屏幕刷新包含的技术名词挺多的，比如刷新率、帧率、双重缓冲、vsync信号等等，我们一个个解释，首先来看刷新率



Android图形架构概述(驱动层)：vsync是如何解决画面撕裂问题的？

> 双缓冲机制
>
> 现在我们跳出Android手机，看看PC的设计
>
> 屏幕板子上有块内存，用于记录像素buffer，屏幕驱动按照刷新率去内存读取，所谓双缓冲，指的
>
> 多重缓冲也是可以的，代价是更高的延迟
>
> 作者：TC130
> 链接：https://zhuanlan.zhihu.com/p/385642198
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 
>
> 假设现在我们只有一个buffer，表示当前需要显示到显示器上的内容。当一帧中的三角形被绘制时，会随着显示器的刷新，逐渐一点点出现，这种效果是很奇怪的。即使我们的帧率和显示器刷新率相等，single buffer 还是会有问题。如果我们决定清除 buffer 然后绘制一个较大的三角形，因为VDC 会将正在绘制的color buffer区域输出，我们就会短暂地看到 color buffer的变化。这种现象叫做**撕裂/tearing**，画面显示看起来被分割成了两部分。在一些像Amiga 的古老系统中，你可以通过检测 Beam来防止画面撕裂，这样single buffering就是可行的。现在只有在一些 VR系统中才会用到这种 single bugger渲染架构，会使用 beam 方式来尽可能降低延迟。
>
> 目前最常用的消除撕裂的方式是使用 double buffering。一个渲染完成的图像在 **front buffer** 中显示，同时不可见的的 **back buffer** 在被绘制。当back buffer 中的图像被传输到显示器后，图形驱动会 swap front buffer 和 back buffer，来避免撕裂。Swap的过程通常都是简单地交换两个 color buffer的指针。对于 CRT 显示器，这个事件叫做 vertical retrace，整个过程叫做 **vertical synchronization / Vsync / 垂直同步**。虽然LCD 显示器没有 beam 的 retace，但是我们使用相同的术语来表示显示器中的交换过程。
>
> 如果渲染过程完成后，立即交换 back buffer 和 front buffer，可以最大化帧率，这样可以用来测试渲染系统的性能。但是这样其实是没有跟随 vsync 来进行更新的，同样会造成撕裂。不过因为两个buffer 都是渲染好的完整图像，撕裂效果不会像 single buffer 中那样糟糕。
>
> 对 double buffering 进行改进，添加上 pending buffer， 就形成了 triple buffering。pending buffer 和 back buffer 类似，都是不可见的，不同的是 pending buffer 是可以被修改的。pending buffer 在交换之后，会变成 back buffer。再次 swap 后，成为 front buffer。这样，三种buffer 构成了循环，如上图所示。
>
> 使用 doule buffering 时，等待垂直刷新及swap时，front buffer 需要被显示，而 back buffer 因为是已经渲染好的图像，所以需要保持不变，等待被显示。相对 double buffering，triple buffering的优势在于，当等待垂直刷新的时候，系统可以访问 pending buffer。这样 triple buffering 避免了等待的时间，从而增加帧率。不过相应的缺点就是，会增加整整一帧的延迟，会给用户从手柄鼠标键盘的输入增加延迟，甚至产生卡顿。
>
> 理论上来说，超过三个的buffer 也是可行的。如果每帧渲染的时间波动很大，使用更多的buffer，就能使结果更平滑，帧率更高，当然代价就是更大的延迟。

Android图形架构概述(系统层)：Flutter没有继承View为什么能在屏幕上显示？

> 在Android4.1之前是不支持vsync信号的，哪怕硬件驱动支持
>
> 在驱动层我们知道，VSync信号是由GPU驱动或者屏幕驱动产生的，假设手机驱动不支持怎么办？
>
> Android4.1中提供了*VSyncThread*来软件模拟
>
> 引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作
>
> 画图：你使用canvas api 还是OpenGL es都可以
>
> 合成：surfaceFligler只管合成图像
>
> 疑问❓：三重缓冲

Android图形架构概述(番外篇)：Input事件先到达DecorView还是Activity？

View系列开篇：什么是刷新率

事情是这样的，

屏幕显示原理：    

LCD屏幕：DC调光

OLED屏幕：PWM调光

逐行刷新

屏幕撕裂

vsync信号

引申出屏幕gif动图

市面上手机屏幕分为两种

一种是LCD屏幕，使用DC调光

屏幕其实是由一个个像素点组成的，每个像素点





范围：  
屏幕的显示原理  
    逐列刷新、逐行刷新
    屏幕最终要的数据类型是每一行的RGB值，

    调光方式，DC调光和PWM调光
    有了上述理论知识以后，我们来看一个现象，这有什么用呢？我们可以看到很有趣的现象
    
    快门速度：
    简单来说就是曝光时间，快门帘打开让光线进入传感器的时间
    
    占空比：
    PWM一个周期计算公式：
    T = 1/f
    周期 = 
    
    我们看到的是什么？


屏幕撕裂

垂直同步信号

讨论一下，高刷屏对于工程师的挑战

对于硬件工程师来说，大部分主板上CPU和GPU共享一块内存，所以屏幕色深值越高，描述每个像素点需要内存就越大，内存的大小和内存的访问速度绝不能拉胯
屏幕刷新率高了，CPU和GPU需要在更短的时间处理数据，在提升硬件性能的同时还需要平衡功耗控制

对于应用开发工程师来说，在View绘制，做好性能优化这块展开可以聊很久

B站评论
科普下，我是做FPGA摄像头视频采集的。摄像头原始出来的格式常用的是RGB565。也就是R红色占5位，G绿色占6位，B蓝色占5位。加起来刚好16位，两个字节。   而显示器需要的是RGB888格式如其名，每个像素占8位。有就是三个字节。  1920x1080个像素点如果是RGB565格式一帧图片多大呢你算下大概6.2M，那显示40帧多少呢一秒就需要248M。注意是1秒哦。    所以图像不压缩真的真的太大了。所以流水线串行的CPU根本处理不了图像。理论上可以，就是巨慢。  所以才会有显卡。并行的1900个流处理器同时处理那么多像素。比cpu快多了。

## 结语

文章内容是应用工程师对驱动开发的理解，若有偏差请在评论区指出，感谢

这是显示端，在拍摄端

> 更高的刷新率意味着需要：
> 更快的处理速度，更高规格的CPU、GPU
> 更大容量的电池
> 更高的触控采样率

## 参考资料

- OLED的几种驱动方式：https://wenku.baidu.com/view/9a1279ceda38376baf1fae70.html?re=view

## 待办

### 1、本章涵盖知识点

1. 屏幕显示原理
   1. 逐行扫描：从上到下从左到右的顺序，多行一起替换，需要电路板佐证
      1. 介绍逐行扫描的概念
      2. 看一张动图，解释这不是逐行扫描但是可以看做是逐行扫描
      3. 看电路图，解释虽然是从上到下从左到右的顺序，但是实际执行是多行替换
2. 屏幕刷新率
   1. 帧率和刷新率
      1. 屏幕VBlack的越快，屏幕刷新的就越高，这个周期，或者说刷新的速度，就是屏幕刷新率
      2. 屏幕刷新率取决于什么呢？显然是屏幕本身的素质，也就是屏幕响应时间
      3. 能不能改变屏幕刷新率呢？屏幕刷新率超频，既然屏幕刷新率高低取决于屏幕素质，那刷新率能不能像CPU一样超频使用呢？答案是可以的，虽然我不清楚底层是改驱动实现的还是怎么样，但的确，另外，超频可能会和采样率等挂钩，可能会点击偏移，在超频之前可以去论坛看看有没有成功的先例，就算没问题有的机型可能也会出现卡顿的情况，原因我待会再说
   2. 帧率FPS
      1. 说完了刷新率，我们来看看帧率是什么，我平时打游戏时除了关注网络延迟外，通常还会关注FPS这个指标，FPS越高游戏画面越流畅
3. 画面撕裂的终结者：vsync
   1. 前面介绍了FPS和刷新率之间的关系，接着我们来看一个现象，画面为什么会撕裂呢？不匹配，如何解决呢
      1. 画面撕裂产生的原因，CPU/GPU每次准备好数据后，放到一个单独的缓存区backBuffer，当屏幕准备好之后，将backBuffer数据和frameBuffer数据交换，屏幕只读取frameBuffer缓存区的数据，保证了数据的完整连续性，这里的屏幕是被动的，交换缓存数据的动作有CPU/GPU来执行，那么就有以下几种情况
      2. 帧率大于刷新率，由于显示器时刻都处于“撕裂”状态，GPU完成后替换了当前显示器正在显示的buffer，画面变化幅度较大时可能会被人眼发觉
      3. 刷新率大于帧率，很好理解，显示器显示完一帧后下一帧数据没变，但显示器不管，依旧会刷新像素点，连着掉几次帧数据，感官上就会觉得卡，若这时候显示器显示到一半buffer被替换了，那画面撕裂被人眼捕捉到的概率还是挺大的
   2. vsync信号，带来的问题，浪费显卡性能，如何解决？多重缓冲，带来另一个问题，鼠标IO事件延迟，如何解决
   3. G sync和free sync信号
4. 回到标题
   1. 带来哪些挑战
      1. 屏幕本身素质表现，需要能够快速切换像素，也就是屏幕响应时间
      2. 高性能的CPU和GPU，对于屏幕来说，GPU的性能更加重要，GPU的显存
      3. 主板设计，CPU和GPU共用内存