## 内容大纲

1. 开篇

   1. 文章一介绍了LCD和OLED显示原理，简单回顾一下：
      1. LCD是液晶面板，控制液晶层就可以改变像素颜色
      2. OLED是自发光二极管，控制单个二极管的电压就可以改变像素颜色
      3. 补充一个漏掉的显示器类型，CRT显示器
      4. 放图
      5. CRT显示器是由CRT显示器是靠电子光束激发荧光粉来发光显示
2. 屏幕刷新原理：驱动篇

   1. 好了，这下我们有三种类型的屏幕了，CRT、LCD、OLED，接下来我们思考另一个问题，屏幕是如何刷新的？
   2. CRT：逐行扫描
      1. 我们知道由于荧光粉的特性，点亮后很快就熄灭了，所以电子枪需要一刻不停的扫描，
      2. 答案是快速扫描，扫描方式有很多，比如直线式扫描，圆形扫描，螺旋扫描等等，我们今天要介绍的就是直线式扫描
      3. 直线式扫描分为两种，一种是逐行扫描，一种是隔行扫描
      4. 逐行扫描是最原始的扫描方式，从电视诞生之初一直在使用的就是逐行扫描
      5. 那个时候电影还是胶卷记录和播放，人们想把电影节目也搬到广播电视上，限制于当时广播传输带宽，发明了隔行扫描和隔行传输，也就是广播公司把原本一幅画面的数据分成两场，奇偶行
   3. LCD：大人 时代变了
      1. 因为LCD有电路板的原因，LCD不需要像CRT一样一行行扫描
      1. 那是不是可以理解成LCD不需要逐行扫描了呢？
      1. 是也不是，LCD可以直接寻址，所以理论上只要屏幕芯片性能和带宽足够（注意这里说的是屏幕本身的芯片存储哦，和主板通信主线以及共享的内存无关），可以直接替换所有的
      1. 以一块分辨率为1080P、位深是8bit的显示器举例，1920\*1080\*3\*8bit=5.93MB，显然没有必要上这么大的存储
      1. 但是因为成本的原因，液晶屏的常见技术是[TFT-LCD](https://en.wikipedia.org/wiki/Thin-film-transistor_liquid-crystal_display)，它主要使用[有源矩阵](https://en.wikipedia.org/wiki/Active_matrix)寻址方案来构建图像，说人话就是LCD屏幕是多行一起刷新的，具体一次性刷新多少行要问屏幕厂商..
      1. 驱动分为有源驱动和无源驱动，我没查到两种方式各自的占有率，AMOLED和TFT-LCD都是，有源驱动比无源驱动方便理解一些，接下来关于屏幕刷新的所有言论都是建立在有源驱动之上，也就是TFT有源矩阵
   4. OLED：我不是针对谁
      1. OLED显示原理虽然比在座另外两位要先进不少，但是在刷新方式上和LCD基本上相同
      2. 有区别的一点是OLED可以利用PWM调光来刷新像素，什么意思呢？
      3. 在《文章一》解释了PWM调光是有频率的，我手里的Pixel 3PWM频率是245HZ，显然比普通的屏幕刷新率要高，那么我就可以利用PWM调光重新点亮屏幕的瞬间来顺便刷新像素颜色，那么就导致OLED有两种刷新策略
         1. 显示动画时，和LCD屏幕相同，直接刷新像素点
         2. 显示不重要的时，可以利用PWM调光来刷新UI，比如下图
         3. 我是图片
         4. 程序中运行的是自定义VIEW不停来回在红色和蓝色之间切换，我们可以看到PWM调光深度走到哪，哪里的像素点就会发生变化，代码我放在github仓库了，感兴趣的同学可以下载下来在自己的手机上运行试试看
   5. 小结一下下
      1. 所以一旦CRT没有新的内容，我们看到的雪花屏就是，而LCD和OLED只需要有电就行了，所以如果没有新的内容，我们看到的就是静止画面
      2. 另外，逐行用P标识，隔行用I标识，现在的设备大部分支持的格式都是可以向前兼容，在使用相机录像时，尽可能的选择P结尾的格式；同样的，在用PR导出视频时，一定要选择P结尾的格式，不然就会出现模糊拖影等等
3. 屏幕刷新率是什么？能改吗？

   1. 刷新率
      1. 了解了上述几种屏幕的刷新原理，刷新率其实就很好理解了：单位时间内屏幕刷新的次数，就是屏幕刷新率，表示单位为HZ
      2. 比如常见的60HZ屏幕意思就是1s内屏幕会刷新60次
      3. 刷新率本身很好理解，但不是我们讨论的重点，本章节讨论重点是两个问题：
         1. 刷新率的高低取决于什么？
         2. 手机屏幕的刷新率能不能修改？
      4. 现在的手机屏幕和电脑显示器的刷新率都越来越高，90HZ、120HZ、144HZ等等，在使用高刷显示设备时u1s1，体验是真的好
      5. 既然120HZ设备相较于60HZ的设备体验会上一个台阶，那厂家为啥不把刷新率拉满呢？直接干到10000HZ行不行？是差钱啊还是差事儿？
      6. 刷新率的高低取决于什么？
         1. 对于CRT显示器来说，电子枪按照从左到右、从上而下的顺序进行扫描，在扫描完整个屏幕后为一次刷新，在一秒钟内电子枪移动的速度极限就是CRT显示器的刷新率上限，这玩意儿太老了，我查到的资料有说能到90HZ还有说120HZ，没有更多的资料佐证，大家看个乐就行了
         2. 对于LCD屏幕来说，刷新率的上限取决于屏幕的灰阶响应时间，由于液晶屏的特性，在低温环境下屏幕响应时间会变长
         3. 对于OLED屏幕来说，刷新率的上限和LCD类似，都是取决于屏幕灰阶响应时间，不过由于OLED没有液晶层，所以上限相对LCD会更高的一些
      7. 如何更改手机屏幕的刷新率？
         1. 既然屏幕刷新率高低取决于屏幕素质，那刷新率能不能像CPU一样超频使用呢？
         2. 答案是可以的，比如我手里pixel 3就被我超频到61HZ了，不要问为什么是61HZ，问就是不知道，虽然我不清楚底层是改驱动实现的还是怎么样，但的确，另外，超频可能会和采样率等挂钩，可能会点击偏移，在超频之前可以去论坛看看有没有成功的先例，就算没问题有的机型可能也会出现卡顿的情况，原因我待会再说
         3. 比如三星s20在刚发布的时候就被爆料可以通过adb命令直接修改刷新率
4. 什么是帧率
   1. 说完了刷新率我们接着说帧率（FPS），我们平时打游戏时除了关注网络延迟外，通常还会关注FPS这个指标，FPS越高游戏画面越流畅，那到底什么是帧率？
   2. 要解释这个问题，我们先看看一下电影放映机
   3. 我是放映机动图
   4. 电影放映机的胶片以每秒456毫米8.0英寸的速度（也就是24 fps）穿过投影机，最终投射到幕布上，这就是帧率
   5. 接着我们想想怎么把24帧电影搬到CRT显示器上，
   6. 在计算机时代，我们看到的图形都是实时渲染出来的
   7. 广播电视和DVD时代，视频源是多少帧就是电视机就是多少帧，
   8. 帧率只存在于计算机，
   9. 帧率是画面渲染，早期没有GPU的时候渲染的活都是交给CPU的
5. 60HZ的显示器 + 24FPS的电影 = ？
   1. 刷新率和帧率单独理解都不难，但是将它俩组合在一起时，情况就变了复杂了一些，比如：
      1. 电影通常是24FPS，在我的60HZ的显示器怎么播放？同理，90/120/144HZ是如何播放的？
      2. 我的手机摄像很牛逼，支持120帧录制视频，但是手机的屏幕很拉胯，才60HZ，手机录下来的120FPS视频使用60HZ的屏幕来回放时，看到的是120HZ还是60HZ
      3. 我的显卡很牛逼，

   2. 总结下来就会发现问题可以分为2类：
      1. 刷新率大于帧率：卡，显示器：看，我拿到一幅小姐姐，16.6ms过后，how old are you？
      2. 帧率大于刷新率：无感，显示器：我读我的，你渲你的，但你别瞎切换我的缓存，否则画面会撕裂的

   3. 出现画面撕裂的原因
      1. 解释画面为什么会撕裂首先我们要了解显示器和显卡之间是如何协同工作的
         1. 以Android手机举例，手机屏幕一般都是
         2. 简单来说，板子上电后屏幕驱动代码持有frame buffer内存区的fd，屏幕驱动会按照固定频率读取frame buffer数据
         3. LCD/OLED显示器起码都是双缓存(后续会详细解释什么是双缓存)，屏幕驱动读取的是一个缓存，就叫前缓存吧，显卡绘制的是一个缓存，叫它后缓存吧，显卡一旦绘制完一帧的数据，就会把原先fd指向的内存地址更改成刚刚绘制完的内存地址，注意哦，这个切换动作和显示器无关哦，是显卡通知操作系统：我好了，你来吧，显示器只会一直读数据，不管数据内存地址在哪

      2. 好了，这下我们知道显示器和显卡之间是怎么配合的了，结合上面的LCD/OLED屏幕刷新原理，我们就可以解释为什么会出现画面撕裂了
      3. 因为刷新率和帧率不匹配！！
         1. 不匹配不匹配不匹配，重要的事情要说3遍，并不是说帧率大于
         2. 以一块刷新率为60HZ的LCD屏幕举例，一帧画面停留时间就是16.67ms，假设灰阶响应时间是1ms，你每次刷新完像素后，实际每一帧画面停留时间是16.67-1=15.67ms
         3. 屏幕驱动读取frame buffer时，此时如果画面变化比较大，那你就能看到画面撕裂了
         4. 如果你运气不好，上面的情况连续发生，那你看到的画面就是撕裂，撕裂，撕裂..，就很惨
         5. 这时候如果好死不死的又给我切换了，那屏幕上显示的又是，由于LCD是矩阵刷新，少说也是一行像素一起刷新，所以你能看到的撕裂都是这样一半一半的的，而不是这样的，网上没找到合适的图，我用Excel表画了一下，大概意思到了就行，你懂的吧..
         6. Ps，OLED因为刷新机制和LCD没差别，所以它俩都会出现画面撕裂，出现的原因也是一样的，PC端使用的是LCD屏幕也都一样
6. 画面撕裂的终结者：vsync信号

   1. 接上文，既然画面撕裂是因为刷新率和帧率不匹配，那我们让它俩匹配不就好了，具体怎么做？
   2. 发信号，显示器每次去刚开始读frame buffer或者读完了通知一声儿，显卡再去渲染新的帧数据，这样不就不冲突了嘛
   3. 这个信号就叫做vsync垂直同步信号，虽然vsync能够改善大部分情况下的画面撕裂，但是还是有概率发生的
      1. 为什么呢？延迟和小概率画面撕裂
      2. 开启垂直同步会导致画面和I/O事件延迟好理解，显卡接收到vsync信号后开始渲染工作，在显卡渲染期间如果画面有更新或者有IO事件发生，比如手机屏幕放了个技能，电脑屏幕玩FPS游戏点了鼠标开枪杀人，这些画面更新和I/O事件会被丢弃了
      3. 因为一共就俩buffer，一个显示器在读，一个显卡在渲染写，提现在你的感受就是打游戏时一旦开启了垂直同步，发现鼠标好像不跟手，延迟很大的原因就是介个
      4. 为什么开启了垂直同步信号还是，
      5. 显示器就是个小傻瓜，只会闷头更新，不会抬头看路，
   4. VSync带来的问题是你的游戏帧率会被限制到显示器刷新率及以下，但凡画面复杂度高一些，你的画面就会变卡
   5. 前面介绍了FPS和刷新率之间的关系，接着我们来看一个现象，画面为什么会撕裂呢？不匹配，如何解决呢
      1. 画面撕裂产生的原因，CPU/GPU每次准备好数据后，放到一个单独的缓存区backBuffer，当屏幕准备好之后，将backBuffer数据和frameBuffer数据交换，屏幕只读取frameBuffer缓存区的数据，保证了数据的完整连续性，这里的屏幕是被动的，交换缓存数据的动作有CPU/GPU来执行，那么就有以下几种情况
      2. 帧率大于刷新率，由于显示器时刻都处于“撕裂”状态，GPU完成后替换了当前显示器正在显示的buffer，画面变化幅度较大时可能会被人眼发觉
      3. 刷新率大于帧率，很好理解，显示器显示完一帧后下一帧数据没变，但显示器不管，依旧会刷新像素点，连着掉几次帧数据，感官上就会觉得卡，若这时候显示器显示到一半buffer被替换了，那画面撕裂被人眼捕捉到的概率还是挺大的
   6. vsync信号，带来的问题，浪费显卡性能，如何解决？多重缓冲，带来另一个问题，对于手机来说，是触摸事件会延迟显示，对于PC来说是鼠标IO事件延迟，PC端如何解决，我只知道PC端两大显卡阵营N卡有G sync，英伟达有free sync我累了不想再看了
   7. 手机端暂时还没有这些技术，苹果家估计Android阵营游戏手机厂商肯定会跟进的，触控采样率都出来了，G sync和free sync信号
   8. 小结环节
      1. 阅读完本章节相信你对要不要开启垂直同步应该有自己的理解了，我们这里总结一下
      2. 不要开
7. 总结
   1. 在文章的最后我们来总结本文讲了哪些内容
      1. CRT/LCD/OLED屏幕显示的原理
      2. CRT/LCD/OLED屏幕刷新的原理
         1. CRT是电子枪按照从左到右、从上到下不停的扫描
         2. LCD和OLED一样，可以直接寻址更新像素，所以用的都是矩阵寻址方案，单次起码更新一行像素点

   2. 回到标题带来哪些挑战
      1. 屏幕本身素质表现，需要能够快速切换像素，也就是屏幕响应时间
      2. 高性能的CPU和GPU，对于屏幕来说，GPU的性能更加重要，GPU的显存
      3. 主板设计，CPU和GPU共用内存


对于应用开发工程师来说，虽然我们不需要写驱动程序，但是了解View最终是如何显示到屏幕上还是非常有必要的

本篇是Android图形系列的第二篇文章，依旧是关于屏幕的一些名词解释，和Android系统本身没有太大关系；和第一篇文章不同的是，本篇重点在于刷新率相关知识点，比如：

> **帧率与刷新率的区别，帧率是不是一定要和刷新率匹配，不匹配时多出来的帧率是不是浪费了？**
>
> **垂直同步信号的出现是为了解决什么问题？**
>
> **电脑开启了垂直同步后感觉更卡了？**
>
> **为什么有的应用在60HZ屏幕体验很好，在120HZ屏幕上却出现卡顿？**
>
> **...**

屏幕刷新机制涉及到许多技术名词：隔行/逐行扫描、刷新率、帧率、画面撕裂、垂直同步信号、双重缓存等等，每项技术都是为了解决某个问题而生；因此，为了更好的理解每项技术诞生的背景，建议按照文章顺序进行阅读

overview图片

## 一、开篇 

当今显示设备的分辨率越来越高，知乎早在两年前就出现了[《2020年1080P显示器还值得买吗？》](https://zhuanlan.zhihu.com/p/158075656)的话题讨论

对于消费者来说，同样的物理尺寸下分辨率越高，像素密度（PPI）也就越高，显示效果越细腻，视觉体验也会更好

今天来和大家聊聊，站在应用开发工程师的角度，我是如何理解屏幕刷新的？

## 二、屏幕显示原理

### **CRT显示的基础：隔行/逐行扫描**

手机屏幕和电脑显示器都是由电视机演变而来，“[隔行扫描](https://baike.baidu.com/item/%E9%9A%94%E8%A1%8C%E6%89%AB%E6%8F%8F)”和“[逐行扫描](https://baike.baidu.com/item/%E9%80%90%E8%A1%8C%E6%89%AB%E6%8F%8F)”这两种显示技术就是出自上世纪30年代的CRT电视机，补充一句，CRT电视机就是大屁股电视机，小时候上微机课用的大屁股电脑也是使用CRT技术的显示器

在CRT电视机中，显示器是靠电子束激发屏幕内表面的荧光粉来显示图像的，由于荧光粉被点亮后很快会熄灭，所以电子枪必须循环地不断激发这些点

*图片来源：http://msys-mv.blogspot.com/2010/11/understanding-basic-requirements-to.html*

CRT电子枪扫描的方式很多，比如直线式扫描，圆形扫描，螺旋扫描等等，在这其中，直线式扫描又可分为逐行扫描和隔行扫描，也就是本章节关注的两种方式

*图片来源：*

上图演示了电视机中两种常用直线式扫描方式，左边是“逐行扫描”，右边是“隔行扫描”

> - **逐行扫描：一帧图像按照从上到下、从左到右的顺序地一行接着一行连续扫描而成，这种扫描方式称为“逐行扫描”**
>
> - **隔行扫描：把一幅图像按照奇偶行拆成两场扫描完成的则被称为“隔行扫描”**

“隔行扫描”的视频相较于“逐行扫描”是的视频牺牲了画质，还会产生行间闪烁效应、出现并行现象及出现垂直边沿锯齿化现象等不良效应，是当时的市场需求诞生的产物

> 早期的广播电视播放内容比较单一，大部分是文字广告和音乐之类内容，电影还是使用“电影放映机”来播放的
>
> 电视机发明后，人们想把电影节目也搬到电视节目当中，由于当时的广播电视传输的带宽不够，所以一幅画面的数据会按照奇偶数分成两次传输，其中奇数行称为上场，偶数行称为下场
>
> 电视机每次接收到的都是半幅画面，在PAL制式和NTSC制式中，显示器接受到数据后会先显示奇数行，再显示偶数行，两次显示后凑成一幅完整的图像
>
> 再后来DVD被发明出来，广播传输的带宽不再是瓶颈，所以我们小的时候看的大屁股电视，只要带有DVD接口的都是可以兼容两种不同的扫描方式的

### **LCD/OLED：大人，时代变了**

时间来到了1968年，第一块LCD液晶屏横空出世了；11年后OLED被发现，从2005年开始，OLED屏幕也开始走向一个成熟化的阶段

在《文章一》介绍了两种屏幕的显示原理，简单回顾一下：

> **LCD屏幕：通过控制施加在液晶层上的电压大小来改变每个像素点颜色**
>
> **OLED屏幕：通过改变施加在自发光二极管上的电压大小来控制每个红黄蓝子像素亮度，进而改变每个像素点的颜色**

由于显示原理发生了变化，所以之前在CRT屏幕上使用的逐行扫描和隔行扫描可能不能直接套用在LCD/OLED屏幕上了

**为什么这么说呢？**

因为LCD/OLED屏幕摆脱了电子枪的约束，尤其是OLED，每个像素都可以直接寻址，无需等待电子光束到来才能更新（埃？听起来有点像机械硬盘和固态硬盘的区别）

所以只要我屏幕带宽足够大，大到可以单次可以传输一副完整画面的帧数据，那么我就可以一次性更新所有像素点

**那是不是就可以理解成LCD/OLED屏幕没有逐行/隔行扫描呢？**

答案是NO

OLED分两种方式，一种是直接更新像素，单次更新像素的时间取决于屏幕相应时间，OLED屏幕响应时间可以做到1ms，甚至不到1ms，目前我手里的设备没办法拍摄纪录像素刷新的过程

还有一种是等PWM调光，在《文章一》我们提到了使用PWM调光的手机都会有PWM频率，这个频率往往会大于屏幕的刷新率，所以我们可以等PWM重新点亮的时候顺便更新像素，比如这样

这是使用PWM调光的pixel 3手机，运行的是

### 小结

无论是“逐行扫描”还是“隔行扫描”，都有拍摄、视频源文件、传输和显示这四个概念，这四个概念相通但不相同，本小节介绍的是显示端的屏幕显示技术

每个阶段的四端所用的技术和标准也不相同，例如为了解决电影搬上电视的广播带宽问题，发明了隔行传输，同时显示端配套产生了“隔行扫描”，而隔行扫描视频文件又是到数字视频时代才出现的，目的是为了兼容原有的隔行扫描体系

哦对了，对于爱好摄影的小伙伴有一点需要补充一下，“逐行扫描”的视频后缀用P标识(Progressive)，“隔行扫描”用i标识(Interlaced)，比如1080P意思就是“逐行扫描”的视频，1080i是“隔行扫描”的视频，了解这一点对爱好摄影的小伙伴可能会有所帮助

> - 视频拍摄：我们在拍摄视频时尽可能选择以P结尾的格式，也就是“逐行扫描”比如720P/1080P，如果不小心以720i/1080i格式完成了录制，后期压制时也可以进行反交错
> - 视频制作：在使用PR导出视频时，同样也要选择以P结尾的格式，否则导出是“隔行扫描”的视频，用“逐行扫描”的显示器播放“隔行扫描”的视频会出现横纹、残影、不流畅等现象



## 三、屏幕刷新率和FPS

屏幕刷新包含的技术名词挺多的，刷新率、帧率、双重缓冲、vsync信号等等，我们先来看什么是刷新率

刷新率(Refresh Rate)代表显示器每秒能够显示的画面数量，以Hz（[赫兹](https://baike.baidu.com/item/赫兹/7245576)）为单位，常见的有60HZ、90HZ、144HZ

理论上来说，刷新了超过了多少人眼就无法察觉有什么区别了，刷新率越高越好，那直接把刷新率拉满不就好

### **刷新率的高低取决于什么？**

对于CRT显示器来说，电子枪按照从左到右、从上而下的顺序进行扫描，在扫描完整个屏幕后为一次刷新，在一秒钟内电子枪移动的速度极限就是CRT显示器的刷新率上限

对于LCD屏幕来说，刷新率的上限取决于屏幕的灰阶响应时间，由于液晶屏的特性，在低温环境下屏幕响应时间会变长

对于OLED屏幕来说，刷新率的上限和LCD类似，都是取决于屏幕灰阶响应时间，不过由于OLED没有液晶层，所以上限相对LCD会更高的一些

### **如何更改手机屏幕的刷新率？**

既然屏幕刷新率高低取决于屏幕素质，那刷新率能不能像CPU一样超频使用呢？答案是可以的，虽然我不清楚底层是改驱动实现的还是怎么样，但的确，另外，超频可能会和采样率等挂钩，可能会点击偏移，在超频之前可以去论坛看看有没有成功的先例，就算没问题有的机型可能也会出现卡顿的情况，原因我待会再说

比如三星s20在刚发布的时候就被爆料可以通过adb命令直接修改刷新率

### FPS是什么？

说完了刷新率，我们来看看帧率是什么，我平时打游戏时除了关注网络延迟外，通常还会关注FPS这个指标，FPS越高游戏画面越流畅

### 帧率是不是一定要和刷新率匹配，不匹配时多出来的帧率是不是浪费了？

## 四、画面撕裂的终结者：VSync信号

Android图形架构概述(驱动层)：vsync是如何解决画面撕裂问题的？

> 双缓冲机制
>
> 现在我们跳出Android手机，看看PC的设计
>
> 屏幕板子上有块内存，用于记录像素buffer，屏幕驱动按照刷新率去内存读取，所谓双缓冲，指的
>
> 多重缓冲也是可以的，代价是更高的延迟
>
> 作者：TC130
> 链接：https://zhuanlan.zhihu.com/p/385642198
> 来源：知乎
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 
>
> 假设现在我们只有一个buffer，表示当前需要显示到显示器上的内容。当一帧中的三角形被绘制时，会随着显示器的刷新，逐渐一点点出现，这种效果是很奇怪的。即使我们的帧率和显示器刷新率相等，single buffer 还是会有问题。如果我们决定清除 buffer 然后绘制一个较大的三角形，因为VDC 会将正在绘制的color buffer区域输出，我们就会短暂地看到 color buffer的变化。这种现象叫做**撕裂/tearing**，画面显示看起来被分割成了两部分。在一些像Amiga 的古老系统中，你可以通过检测 Beam来防止画面撕裂，这样single buffering就是可行的。现在只有在一些 VR系统中才会用到这种 single bugger渲染架构，会使用 beam 方式来尽可能降低延迟。
>
> 目前最常用的消除撕裂的方式是使用 double buffering。一个渲染完成的图像在 **front buffer** 中显示，同时不可见的的 **back buffer** 在被绘制。当back buffer 中的图像被传输到显示器后，图形驱动会 swap front buffer 和 back buffer，来避免撕裂。Swap的过程通常都是简单地交换两个 color buffer的指针。对于 CRT 显示器，这个事件叫做 vertical retrace，整个过程叫做 **vertical synchronization / Vsync / 垂直同步**。虽然LCD 显示器没有 beam 的 retace，但是我们使用相同的术语来表示显示器中的交换过程。
>
> 如果渲染过程完成后，立即交换 back buffer 和 front buffer，可以最大化帧率，这样可以用来测试渲染系统的性能。但是这样其实是没有跟随 vsync 来进行更新的，同样会造成撕裂。不过因为两个buffer 都是渲染好的完整图像，撕裂效果不会像 single buffer 中那样糟糕。
>
> 对 double buffering 进行改进，添加上 pending buffer， 就形成了 triple buffering。pending buffer 和 back buffer 类似，都是不可见的，不同的是 pending buffer 是可以被修改的。pending buffer 在交换之后，会变成 back buffer。再次 swap 后，成为 front buffer。这样，三种buffer 构成了循环，如上图所示。
>
> 使用 doule buffering 时，等待垂直刷新及swap时，front buffer 需要被显示，而 back buffer 因为是已经渲染好的图像，所以需要保持不变，等待被显示。相对 double buffering，triple buffering的优势在于，当等待垂直刷新的时候，系统可以访问 pending buffer。这样 triple buffering 避免了等待的时间，从而增加帧率。不过相应的缺点就是，会增加整整一帧的延迟，会给用户从手柄鼠标键盘的输入增加延迟，甚至产生卡顿。
>
> 理论上来说，超过三个的buffer 也是可行的。如果每帧渲染的时间波动很大，使用更多的buffer，就能使结果更平滑，帧率更高，当然代价就是更大的延迟。

Android图形架构概述(系统层)：Flutter没有继承View为什么能在屏幕上显示？

> 在Android4.1之前是不支持vsync信号的，哪怕硬件驱动支持
>
> 在驱动层我们知道，VSync信号是由GPU驱动或者屏幕驱动产生的，假设手机驱动不支持怎么办？
>
> Android4.1中提供了*VSyncThread*来软件模拟
>
> 引入了Vsync(Vertical Syncronization)用于渲染同步，使得App UI和SurfaceFlinger可以按硬件产生的VSync节奏来进行工作
>
> 画图：你使用canvas api 还是OpenGL es都可以
>
> 合成：surfaceFligler只管合成图像
>
> 疑问❓：三重缓冲

垂直同步信号

讨论一下，高刷屏对于工程师的挑战

对于硬件工程师来说，大部分主板上CPU和GPU共享一块内存，所以屏幕色深值越高，描述每个像素点需要内存就越大，内存的大小和内存的访问速度绝不能拉胯
屏幕刷新率高了，CPU和GPU需要在更短的时间处理数据，在提升硬件性能的同时还需要平衡功耗控制

对于应用开发工程师来说，在View绘制，做好性能优化这块展开可以聊很久

B站评论
科普下，我是做FPGA摄像头视频采集的。摄像头原始出来的格式常用的是RGB565。也就是R红色占5位，G绿色占6位，B蓝色占5位。加起来刚好16位，两个字节。   而显示器需要的是RGB888格式如其名，每个像素占8位。有就是三个字节。  1920x1080个像素点如果是RGB565格式一帧图片多大呢你算下大概6.2M，那显示40帧多少呢一秒就需要248M。注意是1秒哦。    所以图像不压缩真的真的太大了。所以流水线串行的CPU根本处理不了图像。理论上可以，就是巨慢。  所以才会有显卡。并行的1900个流处理器同时处理那么多像素。比cpu快多了。

## 结语

文章内容是应用工程师对驱动开发的理解，若有偏差请在评论区指出，感谢

这是显示端，在拍摄端

> 更高的刷新率意味着需要：
> 更快的处理速度，更高规格的CPU、GPU
> 更大容量的电池
> 更高的触控采样率

## 参考资料

- OLED的几种驱动方式：https://wenku.baidu.com/view/9a1279ceda38376baf1fae70.html?re=view
